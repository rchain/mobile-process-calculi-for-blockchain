.. _actors-tuples-and-pi:

*******************************************************************************
Ηθοποιοί,Πλειάδες και π
*******************************************************************************

Rosette
===============================================================================

Στο MCC, η ερευνητική ομάδα Carnot προέβλεψε την εμποροποίηση του Διαδικτύου μια πλήρη δεκαετία προτού φτάσει η Netscape στη φήμη. Η ομάδα Carnot, ωστόσο, επικεντρώθηκε σε αποκεντρωμένες και κατανεμημένες εφαρμογές και ανέπτυξε έναν κόμβο εφαρμογής δικτύου, που ονομάζεται Extensible Services Switch ή ESS, και τη γλώσσα προγραμματισμού Rosette για τον προγραμματισμό αυτών των κόμβων. Στη Rosette / ESS το μοντέλο που εξετάστηκε ήταν το μοντέλο του ηθοποιού. Εδώ μιλάμε συγκεκριμένα για την επεξεργασία του μοντέλου που ανέπτυξε ο Carl Hewitt και τελειοποιήθηκε από τον Gul Agha, ο οποίος στη συνέχεια συμβούλεψε στον σχεδιασμό της Rosette.

Η επεξεργασία της Rosette ήταν εντυπωσιακή στο πεδίο και την κομψότητα. Συγκεκριμένα, η Rosette αποσυνθέτει έναν ηθοποιό σε

* ένα γραμματοκιβώτιο (μια ουρά όπου φτάνουν μηνύματα από τους πελάτες του ηθοποιού)
* μια κατάσταση (μια πλειάδα αξιών)
* ένα meta (μια περιγραφή του πως να έχεις πρόσβαση στις τιμές της κατάσταση από την άποψη των πιο αφηρημένων κλειδιών)
* και ένα κοινόχρηστο αντικείμενο συμπεριφοράς (ένας χάρτης από τύπους μηνυμάτων σε κώδικα που εκτελείται σε απόκριση, περίπου ισοδύναμος με vtable σε γλώσσες όπως C ++)

Η επεξεργασία ενός ηθοποιού αποτελείται από την ανάγνωση του επόμενου μηνύματος στο γραμματοκιβώτιο χρησιμοποιώντας το  κοινόχρηστο αντικείμενο συμπεριφοράς (ή sbo) για να προσδιοριστεί ο κώδικας που θα εκτελεστεί ως απόκριση στο μήνυμα και στη συνέχεια να εκτελεστεί αυτός ο κώδικας σε ένα περιβάλλον όπου οι αναφορές στα πλήκτρα που περιγράφονται στο meta δεσμεύονται σε θέσεις στην κατάσταση της πλειάδας. Αυτός ο κώδικας θα στείλει κυρίως μηνύματα σε άλλους παράγοντες και πιθανόν να περιμένει απαντήσεις.

Ένας ηθοποιός παρέχει μια συνεπή εικόνα της κατάστασης υπό ταυτόχρονη εκτέλεση μέσω μιας ενημέρωσης. δηλαδή, ένας ηθοποιός δεν επεξεργάζεται το επόμενο μήνυμα στο γραμματοκιβώτιο μέχρι να καλέσει την ενημέρωση και ενώ ο ηθοποιός επεξεργάζεται το τρέχον μήνυμα, το γραμματοκιβώτιο θεωρείται κλειδωμένο και περιμένει αιτήματα πελατών. Όταν ένας ηθοποιός καλεί μια ενημέρωση δημιουργείται ένα νέο λογικό νήμα δραστηριότητας για να επεξεργαστεί το επόμενο μήνυμα στην ουρά γραμματοκιβωτίου. Η άποψη αυτού του νήματος για την κατάσταση του ηθοποιού είναι οτιδήποτε παρέχεται στην ενημέρωση. Το προηγούμενο νήμα ενδέχεται να κάνει αλλαγές στην κατάσταση, αλλά δεν είναι ορατές σε όλα τα επόμενα νήματα που επεξεργάζονται τα επόμενα μηνύματα στο γραμματοκιβώτιο και, συνεπώς, σε όλες τις επόμενες αιτήσεις πελατών. Αυτή η προσέγγιση παρέχει μια επεκτάσιμη έννοια της ταυτόχρονης εκτέλεσης που καταρρέει στον μη-ντετερμινισμό της εντολής άφιξης μηνυμάτων σε δοχεία μονού νήματος και επεκτείνεται όταν υπάρχει υποστήριξη επιπέδου συστήματος για να χαρτογραφήσει τα λογικά νήματα σε κάποιο εξωτερικό δοχείο (όπως ένα VM, ένα λειτουργικό σύστημα ή το υλικό, το ίδιο).

Ήδη, αυτό είναι ένα πολύ πιο συνειδητά αρθρωτό μοντέλο ηθοποιών από ό,τι υπάρχει σήμερα στα περισσότερα βιομηχανικά συστήματα (βλ. Πλαίσιο ΑΚΚΑ της Scala). Αυτό που κάνει το μοντέλο Rosette πολύ πιο κομψό, ωστόσο, είναι η απόλυτη δέσμευσή του σε μετά-επίπεδο προγραμματισμού. Στο μοντέλο Rosette, όλα είναι ένας ηθοποιός. Συγκεκριμένα, το γραμματοκιβώτιο ενός ηθοποιού είναι ηθοποιός, και αυτό έχει, με τη σειρά του, ένα γραμματοκιβώτιο, κατάσταση, meta και το sbo. Αξίζει να σημειωθεί ότι η Rosette κάνει αυτό το πλήρως αντανακλαστικό μοντέλο με τη δυνατότητα άπειρης οπισθοδρόμησης να αποδίδει ισόποσα ή καλύτερα από γλώσσες όπως Java ή C #.

Από κάποια άποψη, η δομική αντανάκλαση των ηθοποιών στο μοντέλο Rosette αντηχεί σε γλώσσες όπως η Java όπου οι κλάσεις είναι με τη σειρά τους αντικείμενα που μπορούν  προγραμματιστικά να εξεταστούν και να υπολογιστούν. Ωστόσο, η Rosette πηγαίνει την ανακλαστική αρχή ένα βήμα παραπέρα. Το μοντέλο προσφέρει όχι μόνο δομική αντανάκλαση, αλλά διαδικαστική αντανάκλαση, παρέχοντας μια έννοια συνέχισης συμφιλιωμένη με την ταυτόχρονη εκτέλεση που είναι εγγενής στο μοντέλο. Συγκεκριμένα, όπως ένα μπλοκ μετατόπισης σε μια παρουσίαση οριοθετημένων συνεχίσεων στο στυλ αλλαγής-επαναφοράς καθιστά την αναμενόμενη συνέχιση διαθέσιμη στον κώδικα του μπλοκ, η ανακλαστική μέθοδος της Rosette καθιστά την συνέχιση αναμονής διαθέσιμη ως παράμετρο στη μέθοδο στο σώμα της μεθόδου . Περισσότερα για αυτό αργότερα.

Για να κλείσει αυτή η σύντομη συνοπτική σημείωση ότι η Rosette δεν ήταν απλώς δομικά και διαδικαστικά αντανακλαστική, αλλά και λεκτικά αντανακλαστική. Δηλαδή, όλη η συντακτική δομή των προγραμμάτων στη Rosette είναι επίσης ηθοποιοί! Η αντανακλαστική υποδομή για αυτό παρέχει τη βάση για ένα υγιεινό σύστημα ευρείας κλίμακας, υποστήριξη για συγκεκριμένες γλώσσες ενσωματωμένου τομέα και μια πληθώρα άλλων συντακτικών και συμβολικών χαρακτηριστικών επεξεργασίας που πολλές βιομηχανικές γλώσσες εξακολουθούν να αγωνίζονται να παρέχουν περίπου 20 χρόνια μετά την έναρξη της Rosette.

Tuplespaces
===============================================================================

Περίπου την ίδια χρονική στιγμή που το μοντέλο Rosette διερευνήθηκε για την ανάπτυξη
εφαρμογών σε αυτό το αποκεντρωμένο και κατανεμημένο περιβάλλον, ο Gelernter πρότεινε τα
Tuplespaces. Εδώ η ιδέα είναι να δημιουργηθεί ένα λογικό αποθετήριο πάνω από το φυσικό
και τα επίπεδα επικοινωνίας του Διαδικτύου. Το αποθετήριο είναι ουσιαστικά
οργανωμένο ως μια κατανεμημένη βάση δεδομένων βασικής αξίας, στην οποία τα ζεύγη
κλειδιών-τιμών χρησιμοποιούνται ως μηχανισμοί επικοινωνίας και συντονισμού μεταξύ υπολογισμών.
Ο Gelernter περιγράφει τρεις βασικές λειτουργίες για αλληλεπίδραση με το tuplespace,
:code:`out` για να δημιουργήσετε ένα νέο αντικείμενο δεδομένων στο tuplespace, :code:`in`
για να καταναλώσετε (αφαιρέσετε) ένα αντικείμενο από το tuplespace και :code:`rd` για να διαβάσετε ένα αντικείμενο χωρίς να το αφαιρέσετε

Σε αντίθεση με τα συστήματα μετάδοσης μηνυμάτων, αυτή η προσέγγιση επιτρέπει στους αποστολείς
και τους δέκτες να λειτουργούν χωρίς καμία γνώση του άλλου.
Όταν μια διαδικασία δημιουργεί ένα νέο αποτέλεσμα που οι άλλες διαδικασίες θα χρειαστούν,
απλώς απορρίπτει τα νέα δεδομένα στο tuplespace. Οι διεργασίες που χρειάζονται
δεδομένα μπορούν να το αναζητήσουν σε tuplespace χρησιμοποιώντας αντιστοίχιση μοτίβων.

.. code-block:: lisp

   out("job", 999, "abc")

   in("job", 1000, ?x) ; μπλοκάρει γιατί δεν υπάρχει αντίστοιχη πλειάδα
   in("job", 999, x:string) ; παίρνει αυτή την πλειάδα έξω από το tuplespace, αναθέτοντας το 'abc' στο x


Αυτό δημιουργεί ερωτήματα σχετικά με τον τρόπο με τον οποίο συνεχίζεται η δημοσίευση των δεδομένων και τι συμβαίνει σε υπολογισμούς που αναστέλλονται περιμένοντας ζεύγη κλειδιών-τιμών που δεν υπάρχουν στο tuplespace. Επιπλέον, ο μηχανισμός tuplespace δεν δεσμεύεται από κανένα μοντέλο προγραμματισμού. Οι πράκτορες που χρησιμοποιούν το tuplespace μπορούν να γράφονται σε μια μεγάλη ποικιλία μοντέλων προγραμματισμού
με μεγάλη ποικιλία υλοποιήσεων και ερμηνειών της συμφωνηθέντας σημασιολογίας ταυτόχρονης εκτέλεσης. Αυτό κάνει το συλλογισμό σχετικά με τη σημασιολογία μιας εφαρμογής από πολλούς παράγοντες που αλληλεπιδρούν μέσω του tuplespace πολύ, πολύ δυσκολότερα. Ωστόσο, η απλότητα του μοντέλου επικοινωνίας και συντονισμού έχει αποδειχθεί ευρύ και υπήρξαν πολλές υλοποιήσεις της ιδέας tuplespace για τις επόμενες δεκαετίες.

Μια αξιοσημείωτη διαφορά μεταξύ της έννοιας tuplespace του συντονισμού και του μοντέλου του ηθοποιού έγκειται στον κύριο περιορισμό θύρας των ηθοποιών. Ένας ηθοποιός έχει ένα μέρος, το γραμματοκιβώτιό του, όπου ακούει τον υπόλοιπο κόσμο. Τα πραγματικά συστήματα και η πραγματική ανάπτυξη συστημάτων απαιτούν οι εφαρμογές να ακούν συχνά δύο ή περισσότερες πηγές δεδομένων και να συντονίζονται μεταξύ τους. Οι διαδικασίες αποφάσεων ενώσεων/fork, για παράδειγμα, όπου οι αιτήσεις για πληροφορίες δημιουργούνται σε πολλαπλές πηγές δεδομένων και στη συνέχεια ο μεταγενέστερος υπολογισμός αντιπροσωπεύει ένα συνδυασμό των επακόλουθων πληροφοριών που μεταδίδονται από τις αυτόνομες πηγές δεδομένων, είναι αρκετά συνηθισμένες στις διαδικασίες λήψης αποφάσεων από τον άνθρωπο, από την επεξεργασία δανείων , στην ανασκόπηση των ακαδημαϊκών μελετών. Φυσικά είναι δυνατό να κανονίσουμε να έχουμε έναν ηθοποιό που να συντονίζεται ανάμεσα σε πολλούς ηθοποιούς οι οποίοι στη συνέχεια είναι επιφορτισμένοι με το χειρισμό των ανεξάρτητων πηγών δεδομένων. Αυτό παρουσιάζει περισσότερες πληροφορίες στην εφαρμογή και διακόπτει την ενθυλάκωση καθώς οι συντελεστές πρέπει να γνωρίζουν ότι συντονίζονται.

Αντίθετα, το μοντέλο tuplespace είναι κατάλληλο για υπολογισμούς που συντονίζονται σε πολλαπλές αυτόνομες πηγές δεδομένων.

Κατανεμημένες εφαρμογές του λογισμού κινητής επεξεργασίας
===============================================================================

Οι Tomlinson, Lavender και Meredith, μεταξύ άλλων, παρείχαν μια συνειδητοποίηση του μοντέλου tuplespace μέσα στη Rosette/ESS ως μέσο για να ερευνήσουν τα δύο μοντέλα δίπλα-δίπλα και να συγκρίνουν τις εφαρμογές γραμμένες και στα δύο στυλ. Κατά τη διάρκεια αυτής της εργασίας ο Meredith ξεκίνησε μια εντατική έρευνα του λογισμού κινητής επεξεργασίας ως μια τρίτη εναλλακτική λύση στο μοντέλο του ηθοποιού και στο μοντέλο του tuplespace. Ένα από τα βασικά ζητήματα ήταν να γεφυρωθεί η ύπαρξη ενός ομοιόμορφου μοντέλου προγραμματισμού, όπως το μοντέλο ηθοποιού της Rosette, κάνοντας το συλλογισμό για τη σημασιολογία εφαρμογών πολύ ευκολότερο, με την απλή αλλά ευέλικτη έννοια της επικοινωνίας και του συντονισμού που παρέχεται στο μοντέλο tuplespace.

Στον κώδικα που απεικονίζεται παρακάτω, χρησιμοποιούνται τα ονόματα των μεθόδων consume και produce αντί των παραδοσιακών ρημάτων Linda :code:`in` και :code:`out`. Ο λόγος είναι πως όταν ανακαλύφθηκε η αντανακλαστική στρατηγική μεθόδου και στη συνέχεια επεξεργάστηκε χρησιμοποιώντας οριοθετημένες συνεχίσεις, αυτό οδήγησε σε νέες ζωτικές παρατηρήσεις σχετικά με τον κύκλο ζωής των δεδομένων και τη συνέχιση.

.. code-block:: none
   :caption: Μια εφαρμογή του tuplespace στη Rosette παίρνει σημασιολογία

   (defRMethod NameSpace (consume ctxt & location)
    ;;; κάνοντας αυτό μια ανακλαστική μέθοδο - RΜέθοδος - αποκτάμε πρόσβαση στην αναμενόμενη συνέχισης
    ;;; δεσμεύεται στην τυπική παράμετρο ctxt
    (letrec [[[channel ptrn] location]
                   ;;; το κανάλι και το μοτίβο των εισερχόμενων μηνυμάτων που αναζητούν καταστρέφονται και δεσμεύονται
           [subspace (tbl-get chart channel)]
                   ;;; τα εισερχόμενα μηνύματα που σχετίζονται με το κανάλι συλλέγονται σε ένα υποκείμενο
                   ;;; από αυτή την άποψη μπορούμε να δούμε ότι το σημασιολογικό πλαίσιο υποστηρίζει μια σύνθεση
                   ;;; topic / subtopic / sububtopic / ... τεχνική διαμόρφωσης που ενοποιεί τη μετάδοση μηνυμάτων
                   ;;; με πρωτογενή εργαλεία παράδοσης περιεχομένου
                   ;;; το όνομα του καναλιού γίνεται το θέμα και η δομή του μοτίβου γίνεται
                   ;;; το υποτοπικό δέντρο
                   ;;; αυτό επίσης ενοποιείται με την προβολή διεύθυνσης URL για την πρόσβαση σε πόρους
          [candidates (names subspace)]
          [[extractions remainder]
             (fold candidates
               (proc [e acc k]
                   (let [[[hits misses] acc]
                   [binding (match? ptrn e)]]
               (if (miss? binding)
                   (k [hits [e & misses]])
                   (k [[[e binding] & hits] misses])))))]
                     ;;; Σημειώστε ότι αυτό είναι γενικό στην αντιστοίχιση; και να χάσετε; βεβαιώνει
                     ;;; η αντιστοίχιση θα μπορούσε να είναι ενοποίηση (όπως συμβαίνει στο SpecialK) ή θα μπορούσε να είναι
                     ;;; ορισμένα από τα άλλα πρωτόκολλα ειδικού σκοπού
                     ;;; η τιμή γι 'αυτή τη γενικότητα είναι η απόδοση
                     ;;; υπάρχει αξιοπρεπής έρευνα που δείχνει ότι υπάρχουν ιδιότητες κατακερματισμού
                     ;;; που θα μπορούσε να προσφέρει μια καλύτερη από εύλογη προσέγγιση της ενοποίησης
          [[productions consummation]
               (fold extractions
                 (proc [[e binding] acc k]
                   (let [[[productions consumers] acc]
                  [hit (tbl-get subspace e)]]
                     (if (production? hit)
                  (k [[[[e binding] hit] & productions] consumers])
                  (k [productions [[e hit] & consumers]])))))]]
                     ;;; αυτό χωρίζει τις επιτυχίες σε αυτές τις αντιστοιχίσεις που είναι δεδομένα και
                     ;;; αυτές οι αντιστοιχίσεις που είναι συνέχειες
                     ;;; και το υπόλοιπο του κώδικα στέλνει δεδομένα στην αναμενόμενη συνέχιση
                     ;;; και προσθέτει τη συνέχεια σε εκείνες τις αντιστοιχίσεις που αυτή την στιγμή
                     ;;; λιμοκτονούν για δεδομένα
                     ;;; Πρόκειται για μια πολύ πιο λεπτή άποψη των αποκλεισμένων μέσων

      (seq
        (map productions
          (proc [[[ptrn binding] product]]
               (delete subspace ptrn)))
        (map consummation
             (proc [[ptrn consumers]]
               (tbl-add subspace
               ptrn (reverse [ctxt & (reverse consumers)]))))
        (update!)
        (ctxt-rtn ctxt productions))))

.. code-block:: none
   :caption: Μια εφαρμογή Rosette του tuplespace έβαλε σημασιολογία

   ;;; Αυτός ο κωδικός είναι απόλυτα διπλός στον κώδικα των καταναλωτών και έτσι σε όλα τα σχόλια
   ;;; ισχύουν οι αντίστοιχοι κώδικες
   (defRMethod NameSpace (produce ctxt & production)
    (letrec [[[channel ptrn product] production]
           [subspace (tbl-get chart channel)]
          [candidates (names subspace)]
          [[extractions remainder]
             (fold candidates
               (proc [e acc k]
                   (let [[[hits misses] acc]
                   [binding (match? ptrn e)]]
               (if (miss? binding)
                   (k [[e & hits] misses])
                   (k [hits [e & misses]])))))]
          [[productions consummation]
               (fold extractions
                 (proc [[e binding] acc k]
                   (let [[[productions consumers] acc]
                  [hit (tbl-get subspace e)]]
                     (if (production? hit)
                  (k [[[e hit] & productions] consumers])
                  (k [productions [[[e binding] hit] & consumers]])))))]]
      (seq
        (map productions
          (proc [[ptrn prod]] (tbl-add subspace ptrn product)))
        (map consummation
          (proc [[[ptrn binding] consumers]]
          (seq
               (delete subspace ptrn)
               (map consumers
                 (proc [consumer]
                   (send ctxt-rtn consumer [product binding])
                   binding)))))
        (update!)
        (ctxt-rtn ctxt product))))

Στην ουσία, το ερώτημα είναι τι συμβαίνει με ένα ή και τα δύο δεδομένα και τη συνέχιση μετά από μια αίτηση εισαγωγής που ικανοποιεί μια αίτηση εξόδου. Στην παραδοσιακή σημαία tuplespace και π-λογισμικού, τόσο τα δεδομένα όσο και η συνέχιση αφαιρούνται από το κατάστημα. Ωστόσο, είναι απολύτως εφικτό να αφήσετε ένα ή και τα δύο στο κατάστημα μετά το συμβάν. Κάθε ανεξάρτητη επιλογή οδηγεί σε ένα διαφορετικό βασικό παράδειγμα προγραμματισμού.

.. topic:: Παραδοσιακές λειτουργίες DB

   Η κατάργηση της συνέχειας αλλά η έξοδος από τα δεδομένα αποτελεί μια τυπική βάση δεδομένων που διαβάζεται:

   +----------+------------------+-------------------+------------------+----------------------+
   |          | ephemeral - data | persistent - data | ephemeral - data | persistent - data    |
   |          |                  |                   |                  |                      |
   |          | ephemeral - k    | ephemeral - k     | persistent - k   | ephemeral - k        |
   +----------+------------------+-------------------+------------------+----------------------+
   | producer | put              | **store**         | publish          | publish with history |
   +----------+------------------+-------------------+------------------+----------------------+
   | consumer | get              | **read**          | subscribe        | subscribe            |
   +----------+------------------+-------------------+------------------+----------------------+


.. topic:: Παραδοσιακές λειτουργίες ανταλλαγής μηνυμάτων

   Καταργοντας την συνέχιση, αλλά αφήνοντας τα δεδομένα αποτελεί πρότυπη ανάγνωση βάσης δεδομένων:

   +----------+------------------+-------------------+------------------+--------------------------+
   |          | ephemeral - data | persistent - data | ephemeral - data | persistent - data        |
   |          |                  |                   |                  |                          |
   |          | ephemeral - k    | ephemeral - k     | persistent - k   | ephemeral - k            |
   +----------+------------------+-------------------+------------------+--------------------------+
   | producer | put              | store             | **publish**      | **publish with history** |
   +----------+------------------+-------------------+------------------+--------------------------+
   | consumer | get              | read              | **subscribe**    | **subscribe**            |
   +----------+------------------+-------------------+------------------+--------------------------+

.. topic:: Αντικατάσταση στοιχείου σε μια κατανεμημένη ρύθμιση

   Η κατάργηση των δεδομένων και η συνέχιση είναι οι τυπικές υπολογιστικές διεργασίες κινητών και η σημασιολογία tuplespace:

   +----------+------------------+-------------------+------------------+----------------------+
   |          | ephemeral - data | persistent - data | ephemeral - data | persistent - data    |
   |          |                  |                   |                  |                      |
   |          | ephemeral - k    | ephemeral - k     | persistent - k   | ephemeral - k        |
   +----------+------------------+-------------------+------------------+----------------------+
   | producer | **put**          | store             | publish          | publish with history |
   +----------+------------------+-------------------+------------------+----------------------+
   | consumer | **get**          | read              | subscribe        | subscribe            |
   +----------+------------------+-------------------+------------------+----------------------+

Με βάση τις ιδέες του Tomlinson σχετικά με τη χρήση των ανακλαστικών μεθόδων της Rosette για να μοντελοποιήσει τη σημασιολογία tuplespace (βλέπε κώδικα παραπάνω), ο Meredith παρείχε μια άμεση κωδικοποίηση του π-λογισμού σε σημασιολογία tuplespace με γραμμικές συνέχειες. Αυτή η σημασιολογία ήταν στο επίκεντρο της μηχανής ενορχήστρωσης διεργασιών της BizTalk της Microsoft, και το XLang της Microsoft, αναμφισβήτητα η πρώτη γλώσσα έξυπνων συμβολαιων κλίμακας Διαδικτύου, ήταν το προκύπτον μοντέλο προγραμματισμού. Αυτό το μοντέλο είχε άμεση επίδραση στα πρότυπα του W3C, όπως η BEPL και η WS-Choreography, και δημιούργησε μια ολόκληρη γενιά εφαρμογών και πλαισίων αυτοματοποίησης επιχειρηματικών διαδικασιών.

Όπως και με τις βελτιώσεις που φέρνει η Rosette στο μοντέλο του ηθοποιού, ο π-λογισμός φέρνει μια συγκεκριμένη οντολογία για εφαρμογές που βασίζονται στην έννοια των διαδικασιών που επικοινωνούν μέσω μηνύματος που διέρχεται από κανάλια. Είναι σημαντικό να σημειωθεί ότι η έννοια της διαδικασίας είναι παραμετρική σε μια έννοια καναλιού και ο Meredith χρησιμοποίησε αυτό το επίπεδο αφαίρεσης για να παρέχει μια μεγάλη ποικιλία τύπων καναλιών στο XLang, συμπεριλαμβανομένων των δεσμών με τις ουρές μηνυμάτων MSMQ της Microsoft, αντικείμενα COM και πολλά άλλα σημεία πρόσβασης στις δημοφιλείς τεχνολογίες της εποχής. Ίσως το πιο κεντρικό στοιχείο των σημερινών αφηρημάτων του Διαδικτύου είναι ότι τα URI παρέχουν μια φυσική έννοια του καναλιού που επιτρέπει την υλοποίηση του μοντέλου προγραμματισμού μέσω ενήμερων σχετικα με URI πρωτοκόλλων επικοινωνίας  , όπως το http. Παρομοίως, από την άποψη του σημερινού κλίματος αποθήκευσης, τα κλειδιά σε μία αποθήκη κλειδιών-τιμων, όπως μια βάση δεδομένων nosql επίσης χαρτογραφει απευθείας στην έννοια του καναλιού στον π-λογισμό και ο Meredith χρησιμοποίησε αυτήν την ιδέα για να παρέχει την κωδικοποίηση του π-λογισμού σε σημασιολογία tuplespace.

Από Tuplespaces σε Π-λογισμό
-------------------------------------------------------------------------------

Ο Π-λογισμός καταγράφει ένα βασικό μοντέλο ταυτόχρονης εκτέλεσης υπολογισμού που βασίζεται στην αλληλεπίδραση μέσω της μετάδοσης μηνυμάτων. Παίζει τον ίδιο ρόλο στον ταυτόχρονο και κατανεμημένο υπολογισμό, καθώς ο λογισμός lambda παίζει για τις λειτουργικές γλώσσες και τον λειτουργικό προγραμματισμό, ορίζοντας τη βασική οντολογία του υπολογισμού και μετατρέποντάς την σε μια σύνταξη και σημασιολογία στην οποία μπορούν να πραγματοποιηθούν οι υπολογισμοί. Δεδομένης της έννοιας του καναλιού, χτίζει μια χούφτα βασικών μορφών διεργασίας, τα πρώτα τρία από τα οποία αφορούν την Ι/Ο, περιγράφοντας τις ενέργειες μετάδοσης μηνυμάτων.

* :code:`0` είναι η μορφή της αδρανούς ή σταματημένης διαδικασίας που είναι η βάση του μοντέλου
* :code:`x? (ptrn) P` είναι η μορφή μιας εισόδου-φυλασσόμενης διαδικασίας που περιμένει ένα μήνυμα σε
κανάλι: κωδικός: `x` που ταιριάζει με ένα πρότυπο, ptrn, και κατά τη λήψη ενός τέτοιου μηνύματος θα
συνεχίσετε με την εκτέλεση: code: `P` σε ένα περιβάλλον όπου υπάρχουν μεταβλητές στο μοτίβο
δεσμεύονται στις τιμές του μηνύματος
* :code:`x! (m)` είναι η μορφή αποστολής ενός μηνύματος:: κωδικός: `m`, σε ένα κανάλι: code:` x`

Τα άλλα τρία αφορούν την ταυτόχρονη φύση των διαδικασιών, τη δημιουργία καναλιών και την επανάληψη.

* :code:`P | Q` είναι η μορφή μιας διαδικασίας που είναι η παράλληλη σύνθεση δύο διαδικασιών P και Q όπου και οι δύο διαδικασίες εκτελούνται ταυτόχρονα
* :code:`(νέο x) P` είναι η μορφή μιας διαδικασίας που εκτελεί μια υποδιαδικασία, P, σε ένα πλαίσιο στο οποίο το x είναι δεσμευμένο σε ένα νέο κανάλι, διαφορετικό από όλα τα άλλα κανάλια που χρησιμοποιούνται
* :code:`(def X (ptrn) = P) [m]` και: code: `X (m)`, αυτές είναι οι φόρμες διαδικασίας για τον αναδρομικό ορισμό και την επίκληση

Αυτές οι βασικές μορφές μπορούν να ερμηνευτούν από την άποψη των λειτουργιών σε Tuplespaces ::

 P,Q ::=                     [[-]](-) : π -> Scala =
     0                       { }
     | x?(prtn)P             { val ptrn = T.get([[x]](T)); [[T]](P) }
     | x!(m)                 T.put([[x]], m)
     | P|Q                   spawn{ [[P]](T)  }; spawn{ [[P]](T) }
     | (new x)P              { val x = T.fresh("x"); [[P]](T) }
     | (def X(ptrn) = P)(m)  object X { def apply(ptrn) = { [[P]](T) } }; X(m)
     | X(ptrn)               X(ptrn)

Μοναδικά δομημένη αφαίρεση καναλιών
-------------------------------------------------------------------------------

Ο Meredith τοτε ακολούθησε δύο διαφορετικές γραμμές βελτίωσης αυτών των χαρακτηριστικών. Και οι δύο σχετίζονται με την αφαίρεση του καναλιού. Το πρώτο από αυτά σχετίζεται με την αφαίρεση του καναλιού στην αφαίρεση μετάδοσης που έχει γίνει τόσο δημοφιλής στο πρότυπο αντιδραστικού προγραμματισμού. Συγκεκριμένα, είναι εύκολο να αποδειχθεί ότι ένα κανάλι στον ασύγχρονο π-λογισμό αντιστοιχεί σε μια απεριόριστη και επίμονη ουρά. Αυτή η ουρά μπορεί να θεωρηθεί ως μετάδοση και η πρόσβαση στη μετάδοση επεξεργάζεται μοναδικά, όπως συμβαίνει με το παράδειγμα αντιδραστικού προγραμματισμού. Αυτό έχει το πρόσθετο πλεονέκτημα ότι παρέχει μια φυσική σύνταξη και σημασιολογία για το μοτίβο ενωσης/fork τόσο ευρέως διαδεδομένο στις εφαρμογές ταυτόχρονης εκτέλεσης που υποστηρίζουν τις εφαρμογές λήψης ανθρωπινων αποφάσεων που αναφέρθηκαν προηγουμένως.

.. code-block:: none

  ( let [[data (consume ns channel pattern)]] P)

.. code-block:: scala

  for( data <- ns.consume(channel, pattern) ){ P }

Αυτό το σημείο αξίζει να συζητηθεί λεπτομερέστερα. Ενώ ο π-λογισμός επιλύει τον αρχικό περιορισμό της θύρας του μοντέλου του ηθοποιού, δεν παρέχει φυσική συνταξη ή υποστήριξη σημασιολογίας για το μοτίβο ενωσης/fork. Ορισμένες παραλλαγές του Π-λογισμου, όπως ο λογισμός της ένωσης, έχουν προταθεί για την επίλυση αυτής της έντασης, αλλά αναμφίβολα αυτές οι προτάσεις υποφέρουν από εμπλοκή χαρακτηριστικών που τα καθιστούν ακατάλληλα για πολλά σχέδια μοτίβου κατανεμημένων και αποκεντρωμένων προγραμματισμών. Εν τω μεταξύ, η μοναδική ερμηνεία του καναλιού παρέχει μια πολύ πιο εστιασμένη και στοιχειώδη ανακατασκευη της σημασιολογίας π-λογισμού, συνεπής με όλες τις υπάρχουσες δηλωτικές σημασιολογίες του μοντέλου, που παρέχει μια φυσική έννοια της ενωσης/fork, ενώ ταυτόχρονα χαρτογραφεί καθαρά στο παραδειγμα αντιδραστικου προγραμματισμου, καθιστώντας έτσι την ενσωμάτωση των αναπτυξιακών στοίβων, όπως το Apache Spark, σχετικά απλή.

Αν εξετάσουμε αυτό από την οπτική της εξέλιξης της γλώσσας προγραμματισμού, βλέπουμε πρώτα μία ανακατασκευη της σημασιολογίας να μοιάζει με:

.. code-block:: none
   :emphasize-lines: 3

   P,Q ::=                     [[-]](-) : π -> Scala =
       0                       { }
       | x?(prtn)P             for( ptrn <- [[x]](T) ){ [[P]](T) }
       | x!(m)                 T.put([[x]], m)
       | P|Q                   spawn{ [[P]](T)  }; spawn{ [[P]](T) }
       | (new x)P              { val x = T.fresh("x"); [[P]](T) }
       | (def X(ptrn) = P)(m)  object X { def apply(ptrn) = { [[P]](T) } }; X(m)
       | X(ptrn)               X(ptrn)

όπου η κατανόηση είναι συντακτικα ομορφη για τη χρήση της συνέχειας
μονάδα. Η επιτυχία αυτής της ερμηνείας υποδηλώνει τον επαναπροσδιορισμό του
**πηγή** της διερμηνείας.

.. code-block:: none
   :emphasize-lines: 2

   P,Q :: = 0
            | for (ptrn <- x)P
            | x!(m)
            | P|Q
            | (new x)P
            | (def X(ptrn) = P)[m]
            | X(ptrn)

Αυτός ο επαναπροσδιορισμος εμφανίζεται στο έργο των Meredith και Stay για υψηλότερη κατηγορηματική σημασιολογία για τον π-λογισμό: cite: `DBLP: journals / corr / StayM15` και στη συνέχεια ενσωματώνεται στο σχέδιο rholang. Το σημαντικό σημείο που πρέπει να σημειωθεί είναι ότι η είσοδος που βασίζεται στην κατανόηση μπορεί τώρα να επεκταθεί ομαλά στην είσοδο από πολλαπλές πηγές, καθένα / όλα από τα οποία πρέπει να περάσουν απο ένα φίλτρο, πριν την επίκληση της συνέχειας.

.. math::

  for( ptrn_{1} \leftarrow x_{1}; \dotso; ptrn_{n} \leftarrow x_{n} if cond )P

Χρησιμοποιώντας μια κατανόηση, η σημασιολογική φρουρά εισόδου μπορεί να είναι παραμετρική στο μονοπάτι που χρησιμοποιείται για κανάλια και επομένως η συγκεκριμένη σημασιολογική σύνδεση μπορεί να παρέχεται πολυμορφικά. Η σημασία αυτού δεν μπορεί να υπερτονιστει. ΕΙΔΙΚΑ:

* Αντιφάσκει με το λογισμο ενωσης, όπου η ένωση είναι αδιαχώριστα
συνδεδεμενη με την υποτροπή. Ο μοναδικος φυλακας εισαγωγης επιτρέπει ανώνυμα,
ενωσεις μιας φορας, οι οποίες είναι αρκετά βασικες σε μοτίβα ενωσης/fork σε
διαδικασίες ανθρωπινων αποφασεων.
* Παρέχει τη κατάλληλη ρύθμιση για την ερμηνεία του Kiselyov
LogicT μετασχηματιστή. Αναζητώντας κάθε πηγή εισόδου μέχρι μια πλειάδα εισοδων
που ικανοποιούν τις συνθήκες, είναι ευαίσθητες στην απόκλιση σε
κάθε πηγή εισόδου. Η δίκαιη διεμπλοκή, και το σημαντικότερο, ένα μέσο για
να περιγράψουμε με προγραμματισμό την πολιτική διασποράς είναι κρίσιμη για τις αξιόπιστες,
διαθέσιμες και αποδοτικές υπηρεσίες. Αυτή είναι η πραγματική εισαγωγή του LogicT
και το σωστό πλαίσιο για την ανάπτυξη αυτών των μηχανημάτων.
* Έχουμε τώρα μια συντακτική μορφή για ένθετες συναλλαγές. ΕΙΔΙΚΑ,
  :code:`P` μπορεί να τρέξει μόνο σε ένα πλαίσιο στο οποίο όλες οι αλλαγές καταστασης που σχετίζονται
με τις πηγές εισόδου και την κατάσταση πληρούνται. Επιπλέον, :code:`P` can be
  μια άλλη διαδικασία που προστατεύεται από την είσοδο. Έτσι, ένας προγραμματιστής ή ένας αναλυτής προγράμματος,
μπορεί να εντοπίσει σύνορα συναλλαγών *συντακτικά*. Αυτό είναι ζωτικής σημασίας για τα συμβολαια
που αφορούν οικονομικές και άλλες κρίσιμες συναλλαγές.

Ένα προ-RChain μοντέλο για έξυπνα συμβολαια
-------------------------------------------------------------------------------

Πρόκειται για ένα πρόδρομο του μοντέλου RChain για έξυπνα συμβολαια, όπως κωδικοποιήθηκε στο σχέδιο rholang. Παρέχει το πλουσιότερο σύνολο πρωτογενών εργαλειων επικοινωνιας για συμβόλαια κτιρίων που έχουν προταθεί μέχρι σήμερα και που οδήγησε τόσο στη θεωρία όσο και στην υλοποίηση και την ανάπτυξη της βιομηχανικής κλίμακας. Ωστόσο, ολόκληρο το σύνολο των πρωτογενων εργαλειων συμβολαιων ταιριάζει σε μία γραμμή. Δεν υπάρχει ούτε μία πρόταση σχεδιασμού σε αυτό το χώρο, από το blockchain με βάση το PoW έως το EVM, που ανταποκρίνεται στις πιέσεις διασφάλισης της ποιότητας που έχει αντιμετωπίσει αυτή η πρόταση. Συγκεκριμένα, η πρόταση συγκεντρωνει όλες τις εμπειρίες χρησιμοποιωντας τα Rosette, Tuplespaces και BizTalk και τα συμπυκνωνει σε ένα ενιαίο σχέδιο που ικανοποιεί τα επιθυμητά που ανακαλύφθηκαν σε όλες αυτές τις προσπάθειες. Αυτό συμβαίνει με μόνο επτά πρωτόγενη εργαλεια και πρωτόγενη εργαλεια που ευθυγραμμίζονται με τα κυρίαρχα παραδείγματα προγραμματισμού της τρέχουσας αγοράς. Ωστόσο, όπως δείχνουν τα παραδείγματα από το spec rholang και τη μελετη για την πρόληψη του σφάλματος στο DAO με τύπους συμπεριφοράς, ολόκληρο το φάσμα των συμβολαιων που εκφράζονται στην υπάρχουσα τεχνολογία blockchain εκφράζεται συμπαγώς σε αυτό το μοντέλο.

Όπως φαίνεται στο σχεδιασμό της rholang, ωστόσο, αυτό είναι μόνο η αρχή της ιστορίας. Ένα μικρό υπόβαθρο είναι απαραίτητο για να κατανοήσουμε την εισαγωγή ή αυτή την εξέλιξη. Τα τελευταία 20 χρόνια έχει γίνει μια ήρεμη επανάσταση στην επιστήμη των υπολογιστών και στη λογική. Για πολλά χρόνια ήταν γνωστό ότι για μικρό, αλλά αυξανόμενο κομμάτι των τύπων μοντέλου λειτουργικού προγραμματισμού αντιστοιχούσαν σε προτάσεις και οι αποδείξεις αντιστοιχούσαν σε προγράμματα. Εάν η αλληλογραφία, γνωστή ποικιλομορφα ως παραδειγμα προτασεων-ως-τυποι ή ως ισομορφισμος του Curry-Howard, μπορεί να χρησιμοποιηθεί για να καλύψει ένα σημαντικό και πρακτικό μέρος του μοντέλου, έχει βαθιές επιπτώσεις στην ανάπτυξη λογισμικού. Τουλάχιστον σημαίνει ότι η συνήθης πρακτική των προγραμμάτων ελέγχου τύπου συμπίπτει με τα αποδεικτικά στοιχεία ότι τα προγράμματα έχουν ορισμένες ιδιότητες ως μέρος της εκτέλεσης τους. Οι ιδιότητες που συνδέονται με το αρχικό θραύσμα που καλύπτεται από τον ισομορφισμό Curry-Howard είχαν σε μεγάλο βαθμό να κάνουν με το σεβασμό της μορφής των δεδομένων που ρέουν μέσα και έξω από τις λειτουργίες, εξαλείφοντας αποτελεσματικά ορισμένες κατηγορίες παραβιάσεων της πρόσβασης στη μνήμη.

Με την έλευση της γραμμικής λογικής του J-Y Girard, παρατηρήσαμε μία δραματική επέκταση του παραδείγματος των προτάσεων ως προς τα είδη. Με γραμμική λογική βλέπουμε την επέκταση της κάλυψης πολύ πέρα ​​από το λειτουργικό μοντέλο, το οποίο είναι αυστηρά διαδοχικό. Αντ 'αυτού, η κάλυψη που προσφέρεται από τον έλεγχο τύπου για την απόδειξη ιδιοτήτων επεκτείνεται στους ελέγχους συμμόρφωσης πρωτοκόλλου στην παράλληλη εκτέλεση. Στη συνέχεια οι Caires και Cardelli ανακάλυψαν τις χωρικές λογικές οι οποίες επέκτειναν περαιτέρω την κάλυψη ώστε να συμπεριλάβουν τις δομικές ιδιότητες του εσωτερικού σχήματος των προγραμμάτων. Βασιζόμενοι σε αυτές τις ανακαλύψεις, ο Stay και ο Meredith αναγνώρισαν έναν αλγόριθμο, τον αλγόριθμο LADL, για τη δημιουργία συστημάτων τύπου, ώστε τα καλά δακτυλογραφημένα προγράμματα να απολαμβάνουν μια ευρεία ποικιλία διαρθρωτικών και συμπεριφορικών ιδιοτήτων που κυμαίνονται από την ασφάλεια και τη ζωή έως τις ιδιότητες ασφαλείας. Με την εφαρμογή του αλγορίθμου LADL που αναπτύχθηκε από την Stay και την Meredith, αυτό το untyped πρότυπο των πρωτόγενων εργαλειων συμβολαίων που προσδιορίζονται εδώ μπορεί να δώσει ένα σωστό και πλήρες σύστημα, αρκετά πλούσιο ώστε να παρέχει εγγυήσεις χρόνου σύνταξης που εξασφαλίζουν βασικές ιδιότητες ασφάλειας και ζωής, αιτήσεις για τη διαχείριση χρηματοοικονομικών περιουσιακών στοιχείων και άλλων ευαίσθητων περιεχομένων Ένα μόνο παράδειγμα μιας τέτοιας εγγύησης σύνταξης χρόνου είναι αρκετό για να πιάσει και να αποτρέψει το σφάλμα που οδήγησε στην απώλεια των 50 εκατομμυρίων δολαρίων ΗΠΑ από το DAO, κατά τον χρόνο σύνταξης.

SpecialK
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Η μοναδική επεξεργασία της σημασιολογίας καναλιών είναι η διορατικότητα που διερευνήθηκε στη στοίβα SpecialK. Πρώτον, χαρτογραφεί την πρόσβαση σε κανάλια με μονταρισμένο αντιδραστικό προγραμματισμό στυλ για κατανόηση. Δεύτερον, χαρτογραφεί τα κανάλια ταυτόχρονα με την τοπική αποθήκευση που σχετίζεται με ολόκληρο τον κόμβο, καθώς και με ουρές σε μια υποδομή επικοινωνίας AMQP που βασίζεται στον πάροχο μεταξύ των κόμβων. Αυτό παρέχει τη βάση ενός δικτύου παροχής περιεχομένου που μπορεί να υλοποιηθεί μέσω ενός δικτύου επικοινωνούντων κόμβων, το οποίο είναι ενσωματωμένο σε ένα μοντέλο προγραμματισμού που βασίζεται σε π-λογισμό. Συγκεκριμένα, όπως φαίνεται στις παρατηρήσεις στον παραπάνω κώδικα, η μονοβάθμια επεξεργασία του προτύπου + κανάλι ενοποιεί τα παραδείγματα προγραμματισμού παράδοσης μηνυμάτων και περιεχομένου. Συγκεκριμένα, το κανάλι μπορεί να θεωρηθεί ότι παρέχει θέμα, ενώ το μοτίβο παρέχει ένθετη δομή δευτερεύοντως στη ροή μηνυμάτων. Αυτό ενσωματώνει όλους τους τυπικούς μηχανισμούς διευθυνσιοδότησης περιεχομένου, όπως οι διευθύνσεις URL + http, καθώς και ένα μοντέλο ερωτήματος. Ανατρέξτε στην ενότητα παρακάτω για λεπτομέρειες.


Από το SpecialK στο RChain
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Όπως θα δούμε, το μοντέλο RChain για συμβολαια κληρονομεί όλη τη θεραπεία του SpecialK για την παράδοση περιεχομένου. Ωστόσο, όπου η SpecialK συνειδητοποίησε το προ-Rchain μοντέλο σύμβολαιου ως ενσωματωμένη συγκεκριμένη γλώσσα που φιλοξενείται ως σύνολο βιβλιοθηκών στη Scala, το μοντέλο RChain αντιλαμβάνεται το μοντέλο ως μια πλήρης γλώσσα προγραμματισμού που εκτελείται σε ένα VM που αναπαράγεται στο blockchain, πολύ στο πνεύμα της αρχιτεκτονικής και του σχεδιασμού του Ethereum. Αυτή η επιλογή αντιμετωπίζει αρκετές ελλείψεις στην αρχιτεκτονική Synereo V1 όπως περιγράφεται στο πρωτο whitepaper της Synereo. Συγκεκριμένα, αποφεύγει το πρόβλημα της υποχρέωσης πληρωμής αμοιβών σε blockchain για την εκμετάλλευση των οικονομικών δυνατοτήτων της τεταμενης οικονομιας και, ως εκ τούτου, πλήττονται από εναν αριθμο οικονομικων επιθέσεων στα συμβολαια του οικονομικου συστήματος. Επίσης, εξετάζει το τεχνικό χρέος στη στοίβα SpecialK που σχετίζεται με τις οριοθετημενες συνέχισεις στην βιβλιοθηκη της Scala, η οποία βρίσκεται στο επίκεντρο της σημασιολογίας της SpecialK, αυξάνοντας δραματικά την ικανότητα των έξυπνων συμβολαίων που υποστηρίζονται.

λογισμός Rho
-------------------------------------------------------------------------------

Ενώ η μοναδική αφαίρεση παρέχει δομή στη μεταδοση περιεχομένου που ρέει πάνω από κανάλια, μια πιο θεμελιώδης παρατήρηση παρέχει την απαραίτητη δομή για να υποστηρίξει το μετα-επίπεδο προγραμματισμού βιομηχανικής κλίμακας. Είναι σημαντικό να αναγνωρίσουμε ότι ουσιαστικά όλες οι μεγάλες γλώσσες προγραμματισμού υποστηρίζουν προγραμματισμό μετα-επιπέδου. Ο λόγος είναι απλώς το γεγονός ότι οι προγραμματιστές δεν γράφουν προγράμματα. Τα προγράμματα γράφουν προγράμματα. Οι προγραμματιστές γράφουν τα προγράμματα που γράφουν προγράμματα. Αυτός είναι ο τρόπος με τον οποίο ολοκληρώνεται πραγματικά το τεράστιο έργο του προγραμματισμού σε κλίμακα Internet, χρησιμοποιώντας υπολογιστές για την αυτοματοποίηση όσο το δυνατόν περισσότερων εργασιών. Από τους συντάκτες κειμένων σε μεταγλωττιστές σε γεννήτριες κωδικών σε AI, όλα αυτά αποτελούν μέρος του βασικού οικοσυστήματος που περιβάλλει την παραγωγή κώδικα για υπηρεσίες που λειτουργούν σε κλίμακα Internet.

Λαμβάνοντας μια πιο στενή προοπτική, είναι χρήσιμο να παρακολουθήσουμε τις επώδυνες εμπειρίες της Scala για να προσθέσουμε υποστήριξη για προγραμματισμό μετα-επιπέδου μετά από το γεγονός του γλωσσικού σχεδιασμού. Η αντανάκλαση στη Scala δεν ήταν καν ασφαλής απο νηματα για χρόνια. Αναμφισβήτητα, αυτή η εμπειρία, καθώς και τα προβλήματα με το σύστημα τύπου ήταν οι λόγοι για την προσπάθεια του back-to-the-drawing του σκάφους που βασίζεται στον dotty compiler και στη νέα γλωσσική σχεδίαση. Αυτές και άλλες καλά διερευνημένες προσπάθειες καθιστούν σαφές ότι η παροχή πρωτογενων εργαλειων για μετα-επίπεδο προγραμματισμό από την αρχή του κεντρικού σχεδιασμού του μοντέλου προγραμματισμού είναι απαραίτητη για τη μακροζωία και την πρακτική χρήση. Εν ολίγοις, ένα σχέδιο που υποστηρίζει πρακτικά το μετα-επίπεδο προγραμματισμό είναι απλά πιο οικονομικό σε ένα έργο που θέλει να φτάσει στο έτοιμο για παραγωγή χαρακτηριστικό που είναι ίσο με την Java, C # ή Scala.

Λαμβάνοντας υπ 'όψιν τη συνολική δέσμευση της Rosette σε μετα-επίπεδο προγραμματισμό, το
** ανακλαστικός ** ανώτερος ** π-λογισμός, ή λογισμος-rho, για συντομία,
εισάγει τον προβληματισμό ως μέρος του βασικού μοντέλου. Παρέχει δύο βασικά πρωτογενη εργαλεια, αντανακλαση και επαναπιστοποιηση, που επιτρέπουν έναν συνεχή υπολογισμό να μετατρέψει μια διαδικασία σε ένα κανάλι και ένα κανάλι που είναι μια επαναπιστοποιημένη διαδικασία πίσω στη διαδικασία που αυτή επαναλαμβάνει. Το μοντέλο έχει επανεξεταστεί πολλές φορές τα τελευταία δέκα χρόνια. Πρωτότυπα που παρέχουν μια σαφή επίδειξη της ευρωστίας τους είναι διαθέσιμα για σχεδόν μια δεκαετία. Αυτό παίρνει το σύνολο των αρχέγονων συμβολαίων δόμησης σε ένα μεγάλο σύνολο εννέα αρχέγονων, πολύ λιγότεροι από αυτούς που βρέθηκαν στην Solidity, την έξυπνη γλώσσα συμβολαίου του Ethereum, αλλά το μοντέλο είναι πολύ πιο εκφραστικό από την Solidity. Συγκεκριμένα, τα έξυπνα συμβόλαια με βάση τη Solidity δεν απολαμβάνουν εσωτερική ταυτοχρονη εκτελεση.

Συνέπειες για την αντιμετώπιση πόρων, την παράδοση περιεχομένου, την ερώτηση και το sharding
===============================================================================

Πριν μπουμε στο πώς σχετίζεται το μοντέλο με την αναφορά πόρων, την παράδοση περιεχομένου, ερώτημα και sharding, ας κάνουμε μερικές γρήγορες παρατηρήσεις σχετικά με τη διαδρομή που βασίζεται σε διεύθυνση. Σημειώστε ότι οι διαδρομές δεν συνθέτουν πάντα. Για παράδειγμα, πάρτε τα στοιχεία "/ a / b / c" και "/ a / b / d".
Αυτά δεν συνθέτουν φυσικά για να δώσουν μια διαδρομή. Ωστόσο, κάθε διαδρομή είναι αυτόματα ένα δέντρο, και ως δέντρα αυτά συνθέτουν για να δώσουν ένα νέο δέντρο `/ a / b / c + d`. Με άλλα λόγια, τα δέντρα παρέχουν ένα σύνθετο μοντέλο για την αντιμετώπιση των πόρων. Αυτό λειτουργεί επίσης ως μοντέλο ερωτηματος. Για να δείτε αυτό το δεύτερο μισό αυτής της αξίωσης, ας ξαναγράψουμε τα δέντρα μας με αυτή τη μορφή:

.. math::
  /a/b/c \mapsto a(b(c))

.. math::
  /a/b/c+d \mapsto a(b(c, d))

Τότε παρατηρήστε ότι η ενοποίηση λειτουργεί ως ένας φυσικός αλγόριθμος για την αντιστοίχιση και την αποσύνθεση των δένδρων και την αντιστοίχιση και την αποσύνθεση που βασίζονται στην ενοποίηση βάση του ερωτήματος.

Υπό το πρίσμα αυτής της συζήτησης, ας δούμε τις ενέργειες I/O του π-λογισμού:

.. code-block:: none

   είσοδος: x?(a(b(X,Y)))P ↦ for(a(b(X,Y)) <- x)P
   έξοδος: x!(a(b(c,d)))

Όταν αυτά τοποθετούνται σε παράλληλη εκτέλεση έχουμε:

.. code-block:: none

   for(a(b(X,Y)) <- x)P | x!(a(b(c,d)))

 οποία αξιολογείται ως: code: `P {X: = c, Y: = d}`, δηλαδή αρχίζουμε να εκτελούμε
:code:`P` σε περιβάλλον όπου: ο κωδικός:` X` δεσμεύεται: κωδικός: `c`, και
:code:`Y` δεσμεύεται: κωδικός:` d`. Γράφουμε συμβολικά το βήμα της αξιολόγησης:

.. code-block:: none

   for(a(b(X,Y)) <- x)P | x!(a(b(c,d))) → P{ X := c, Y := d }

Αυτό δημιουργεί μια πολύ φυσική ερμηνεία:

* Η έξοδος τοποθετεί πόρους σε τοποθεσίες:

.. code-block:: none

   x!(a(b(c,d)))

* Ερωτήματα εισαγωγής πόρων σε τοποθεσίες:

.. code-block:: none

   for(a(b(X,Y)) <- x)P

Αυτή είναι μόνο η αρχή της ιστορίας. Με την αντανάκλαση αναγνωρίζουμε τη δομή στα ονόματα καναλιών, όπως το x στο παραπάνω παράδειγμα, οι ίδιοι. Αυτό επιτρέπει να υποδιαιρείται ο χώρος όπου οι πόροι αποθηκεύονται μέσω των namespaces. Τα namespces αποτελούν τη βάση για ένα ευρύ φάσμα χαρακτηριστικών από την ασφάλεια έως το sharding.

Το μοντέλο RChain για έξυπνα συμβολαια
-------------------------------------------------------------------------------

Τώρα έχουμε έναν πλήρη χαρακτηρισμό των έξυπνων συμβολαίων του μοντέλου RChain. Κωδικοποιείται στον σχεδιασμό rholang. Ο αριθμός των χαρακτηριστικών που απολαμβάνει ως αποτέλεσμα της αντανάκλασης και μονο, από τις μακροεντολές έως τους προσαρμογείς πρωτοκόλλου, αρκεί για να δικαιολογήσει την προσοχη. Ωστόσο, κάνοντας ένα βήμα πίσω, βλέπουμε περαιτέρω ότι

* Απολαμβάνει ένα σωστό σύστημα τύπου
* μια επίσημη προδιαγραφή
* την απόδοση της επίσημης προδιαγραφής στον κώδικα εργασίας
* αυτό υπαγορεύει μια επίσημη προδιαγραφή μιας VM σωστής κατασκευής
* αυτό υπαγορεύει μια σαφή στρατηγική compilation ως μια σειρά μετασχηματισμών correct-by-construction στον κώδικα byte για ένα VM που έχει δοκιμαστεί για 20 χρόνια

Τώρα συγκρίνετε αυτό το σημείο εκκίνησης με το σημερινό σημείο της Ethereum με το Solidity και το EVM. Εάν ο στόχος είναι να παραχθεί ένα αξιόπιστο χρονοδιάγραμμα πάνω από το οποίο φτάνουμε σε ένα δίκτυο κομβων blockchain που λειτουργούν με επίσημο έλεγχο, κώδικα ορθής κατασκευής, τότε ακόμη και με το φαινόμενο του δικτύου της Ethereum αυτή η προσέγγιση έχει ξεχωριστά πλεονεκτήματα. Είναι σαφές ότι υπάρχει αρκετό ενδιαφέρον απο την αγορά για την υποστήριξη της ανάπτυξης και των δύο επιλογών.

.. bibliography:: reference.bib
   :cited:
